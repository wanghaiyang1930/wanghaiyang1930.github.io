### 数组

```
///> 数组属于数组类型，是固定长度的，因此不能改变数据的长度：

var items [3]int // 声明定义且默认初始化；

a := [3]int{12, 78, 50} // 创建且初始化；
a := [3]int{12} // 创建且局部初始化；
a := [...]int{12, 78, 50} // 创建且推断长度；

///> 数组属于值类型，不具有引用特性：
b := a // a and b 属于两个单独的实体，深拷贝；


///> 数组遍历

for i := 0; i < len(a); i++ {
    fmt.Println(i, a[i])
}

for i, v := range a {
    fmt.Println(i, v)
}

for _, v := range a {
    fmt.Println(v)
}

```

### 切片

```
///> 切片是数组外在引用，因此两个切片进行赋值，属于引用关系；

s := a[1:3] // 创建切片，Range: [1:3)；
s := []int{1, 2, 3} // 创建切片；
s := make([]int, 5, 5) // func make([]T, len, cap)

a := [...]string{"apple", "orange", "grape", "mango", "water melon", "pine apple", "chikoo"}
s := fruitarray[1:3] // len(s)=2 cap(s)=6

s = append(s, 8) // 追加元素
```

### 切片内存优化
切片保留对底层数组的引用，只要切片存在于内存中，数组就不能被垃圾回收。这在内存管理方便可能是值得关注的。假设我们有一个非常大的数组，而我们只需要处理它的一小部分，为此我们创建这个数组的一个切片，并处理这个切片。这里要注意的事情是，数组仍然存在于内存中，因为切片正在引用它。
解决该问题的一个方法是使用 copy() 函数 func copy(dst, src []T) int 来创建该切片的一个拷贝。这样我们就可以使用这个新的切片，原来的数组可以被垃圾回收。